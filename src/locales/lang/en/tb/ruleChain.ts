export default {
  title: 'Rule Chain Library',
  table: {
    name: 'Name',
    description: 'Description',
    debug: 'Debug',
    root: 'Root',
    createdTime: 'Created Time',
  },
  action: {
    add: 'Add Rule Chain',
    setRoot: 'Set as Root',
    edit: 'Edit Rule Chain',
    delete: 'Delete Rule Chain',
    deleteConfirmTitle: 'Are you sure you want to delete the rule chain [{name}]?',
    deleteConfirmContent:
      'Please note: After confirmation, the rule chain and all related data will not be recoverable.',
    deleteSuccess: 'Rule chain deleted successfully!',
    setRootConfirmTitle: 'Are you sure you want to set the rule chain [{name}] as root?',
    setRootConfirmContent:
      'After confirmation, the rule chain will become the root rule chain and will process all incoming transport messages.',
    confirm: 'Confirm',
    setRootSuccess: 'Set root rule chain successfully!',
  },
  form: {
    name: 'Rule Chain Name',
    namePlaceholder: 'Please enter rule chain name',
    debugMode: 'Debug Mode',
    description: 'Description',
    addSuccess: 'Rule chain added successfully!',
    editSuccess: 'Rule chain updated successfully!',
    ruleChainEmpty: 'Rule chain is empty!',
  },
  flow: {
    root: '(Root)',
    deleteSelection: 'Delete selected nodes and connections',
    resetDebug: 'Reset debug mode for all nodes',
    cancelChanges: 'Cancel changes',
    saveChanges: 'Save changes',
    searchRuleNodes: 'Search rule nodes',
    notFound: 'Not found',
    input: 'Input',
    inputDescription: 'Logical input of the rule chain, forwards incoming messages to the next relevant rule node.',
    details: 'Details',
    edit: 'Edit',
    saveSuccess: 'Rule chain saved successfully!',
    unsavedChanges: 'Unsaved changes',
    unsavedChangesContent: 'There are unsaved changes. Are you sure you want to leave this page?',
  },
  node: {
    nodeDetailTitle: 'Rule Node',
    name: 'Node Name',
    debugMode: 'Debug Mode',
    description: 'Description',
    help: 'Help',
    namePlaceholder: 'Please enter node name',
    nameRequired: 'Please enter node name!',
    singletonMode: 'Singleton Mode',
    descriptionPlaceholder: 'Enter node description',
    addNode: 'Add Rule Node',
    editNode: 'Edit Rule Node',
    add: 'Add',
    linkLabel: 'Link Label',
    editNodeLink: 'Edit Rule Node Link',
    addNodeLink: 'Add Rule Node Link',
    linkLabelRequired: 'Please select a link label',
  },
  nodeAction: {
    customerNamePattern: 'Customer name pattern',
    customerNamePatternRequired: 'Customer name pattern is required!',
    customerNamePatternHelp:
      'Use ${metaDataKey} for value from metadata, or $[messageKey] for value from message body.',
    createNewCustomer: 'Create new customer if not exists',
    customerCacheExpiration: 'Customer cache expiration',
    customerCacheExpirationRequired: 'Customer cache expiration is required!',
    customerCacheExpirationHelp:
      'Specifies the maximum time interval that the found customer records are allowed to be stored. 0 value means that records never expire.',
    unitSecond: 's',
    format: 'Format',
    testScript: 'Test script function',
    fullScreen: 'Full screen',
    testDetailsFunction: 'Test details function',
    testScriptModal: {
      title: 'Test Script Function',
      messageType: 'Message Type',
      postTelemetry: 'Post telemetry',
      messageContent: 'Message Content',
      metadata: 'Metadata',
      addMetadata: 'Add',
      key: 'Key',
      value: 'Value',
      transformer: 'Transformer',
      output: 'Output',
      test: 'Test',
      reset: 'Reset',
      close: 'Close',
    },
    alarmType: 'Alarm type',
    alarmTypeRequired: 'Alarm type is required!',
    useMessageAlarmData: 'Use message alarm data',
    overwriteAlarmDetails: 'Overwrite alarm details',
    useAlarmSeverityMapping: 'Use alarm severity mapping',
    alarmSeverity: 'Alarm severity',
    alarmSeverityMapping: 'Alarm severity mapping',
    alarmSeverityMappingRequired: 'Alarm severity mapping is required!',
    alarmSeverityMappingHelp:
      'Use ${metaDataKey} for value from metadata, or $[messageKey] for value from message body. Alarm severity should be one of the system values (CRITICAL, MAJOR, etc)',
    propagateToRelated: 'Propagate alarm to related entities',
    relationTypesToPropagate: 'Relation types to propagate',
    propagateToOwner: 'Propagate alarm to entity owner (customer or tenant)',
    propagateToTenant: 'Propagate alarm to tenant',
    direction: 'Direction',
    directionFrom: 'From',
    directionTo: 'To',
    entityType: 'Entity type',
    entityTypeRequired: 'Entity type is required!',
    namePattern: 'Name pattern',
    namePatternRequired: 'Name pattern is required!',
    typePattern: 'Type pattern',
    typePatternRequired: 'Type pattern is required!',
    relationType: 'Relation type',
    relationTypeRequired: 'Relation type is required!',
    createNewEntity: 'Create new entity if not exists',
    createNewEntityHelp: 'If the entity from the pattern above does not exist, create a new entity.',
    removeCurrentRelations: 'Remove current relations',
    removeCurrentRelationsHelp:
      'Removes the current relations of the originator of the incoming message that match direction and type.',
    changeOriginatorToRelatedEntity: 'Change originator to related entity',
    changeOriginatorToRelatedEntityHelp: 'Change the originator of the message to the related entity.',
    entityCacheExpiration: 'Entity cache expiration time',
    entityCacheExpirationRequired: 'Entity cache expiration time is required!',
    entityCacheExpirationHelp:
      'Specifies the maximum time interval that the found entity records are allowed to be stored. 0 value means that records never expire.',
    usePeriodInSecondsPattern: 'Use period in seconds pattern',
    usePeriodInSecondsPatternHelp:
      'If checked, the rule node uses the period in seconds pattern from the message metadata or data, assuming the period is in seconds.',
    periodInSecondsPattern: 'Period in seconds pattern',
    periodInSecondsPatternRequired: 'Period in seconds pattern is required!',
    period: 'Period',
    periodRequired: 'Period is required!',
    maxPendingMsgs: 'Maximum pending messages',
    maxPendingMsgsRequired: 'Maximum pending messages is required!',
    scope: 'Scope',
    scopeRequired: 'Scope is required!',
    keys: 'Keys',
    keysRequired: 'Keys are required!',
    sendAttributesDeletedNotification: 'Send attributes deleted notification',
    sendAttributesDeletedNotificationHelp:
      'Sends a separate notification message about deleted attributes to the Rule Engine queue.',
    notifyDevice: 'Force notify device',
    notifyDeviceHelp:
      'If enabled, forces the notification to the device about the shared attribute deletion. If disabled, the notification behavior is controlled by the "notifyDevice" parameter from the incoming message metadata. To turn on the notification, the message metadata must contain the "notifyDevice" parameter set to "true". In any other case, no notification will be triggered to the device.',
    deleteForSingleEntity: 'Delete relations for a specific entity',
    deleteForSingleEntityHelp:
      'Deletes relations of the originator of an incoming message with a specified entity or list of entities by direction and type.',
    persistAlarmRulesState: 'Persist alarm rules state',
    fetchAlarmRulesStateOnStart: 'Fetch alarm rules state on start',
    messageCount: 'Message count',
    messageCountRequired: 'Message count is required!',
    periodInSeconds: 'Period (seconds)',
    periodInSecondsRequired: 'Period is required!',
    originator: 'Originator',
    queue: 'Queue',
    submitStrategy: 'Submit strategy:',
    processingStrategy: 'Processing strategy:',
    testGenerateFunction: 'Test generate function',
    latitudeKeyName: 'Latitude key name',
    latitudeKeyNameRequired: 'Latitude key name is required!',
    longitudeKeyName: 'Longitude key name',
    longitudeKeyNameRequired: 'Longitude key name is required!',
    perimeterType: 'Perimeter type',
    perimeterTypeRequired: 'Perimeter type is required!',
    perimeterTypePolygon: 'Polygon',
    perimeterTypeCircle: 'Circle',
    fetchPerimeterFromMetadata: 'Fetch perimeter information from message metadata',
    perimeterKeyName: 'Perimeter key name',
    perimeterKeyNameRequired: 'Perimeter key name is required!',
    perimeterKeyNameHelp: 'The name of the message metadata field that contains perimeter information.',
    polygonsDefinition: 'Polygons definition',
    polygonsDefinitionRequired: 'Polygons definition is required!',
    polygonsDefinitionHelp:
      'Manually define polygons using the following format: [[lat1, lon1], [lat2, lon2], ..., [latN, lonN]].',
    centerLatitude: 'Center latitude',
    centerLatitudeRequired: 'Center latitude is required!',
    centerLongitude: 'Center longitude',
    centerLongitudeRequired: 'Center longitude is required!',
    range: 'Range',
    rangeRequired: 'Range is required!',
    rangeUnit: 'Range unit',
    rangeUnitRequired: 'Range unit is required!',
    minInsideDuration: 'Min inside duration',
    minOutsideDuration: 'Min outside duration',
    unit: 'Unit',
    meter: 'Meter',
    kilometer: 'Kilometer',
    foot: 'Foot',
    mile: 'Mile',
    nauticalMile: 'Nautical mile',
    testToStringFunction: 'Test toString function',
    function: 'Function',
    functionRequired: 'Function is required!',
    customFunction: 'CUSTOM | Custom function',
    customFunctionHelp: 'Use this function to specify a complex mathematical expression',
    add: 'ADD | Addition',
    subtract: 'SUB | Subtraction',
    multiply: 'MULT | Multiplication',
    divide: 'DIV | Division',
    parameters: 'Parameters',
    argFromMessage: 'Get parameter from Message',
    argFromMetadata: 'Get parameter from Message Metadata',
    argFromAttribute: 'Get parameter from entity Attribute',
    argFromTimeseries: 'Get parameter from entity TimeSeries',
    argConstant: 'Define constant value',
    value: 'Value',
    defaultValue: 'Default value',
    delete: 'Delete',
    addArgument: 'Add',
    mathExpression: 'Mathematical expression',
    mathExpressionHelp:
      'Specify the mathematical expression to be calculated. The default expression demonstrates how to convert Fahrenheit to Celsius',
    result: 'Result',
    type: 'Type',
    resultToMessage: 'Output result to Message',
    resultToMetadata: 'Output result to Message Metadata',
    resultToAttribute: 'Store result in entity Attribute',
    resultToTimeseries: 'Store result in entity TimeSeries',
    key: 'Key',
    precision: 'Digits after floating point',
    precisionHelp: 'Use 0 to convert the result to an integer',
    interval: 'Interval',
    telemetryPrefix: 'Output telemetry key prefix',
    telemetryPrefixRequired: 'Output telemetry key prefix is required',
    requestIdMetaDataAttribute: 'Request Id Metadata attribute name',
    timeout: 'Timeout',
    timeoutRequired: 'Timeout is required!',
    saveAttributesOnlyOnValueChange: 'Save attributes only on value change',
    sendAttributesUpdatedNotification: 'Send attributes updated notification',
    defaultTTL: 'Default TTL (seconds)',
    defaultTTLRequired: 'Default TTL is required!',
    skipLatestPersistence: 'Skip latest persistence',
    useServerTs: 'Use server timestamp',
    useServerTsHelp:
      'Enable this setting to use the timestamp of the message processing instead of the message timestamp. Can be useful for various sequential processing if you merge messages from multiple sources (devices, assets, etc).',
    customTableName: 'Custom table name',
    customTableNameRequired: 'Custom table name is required!',
    customTableNameHelp: "Enter the table name without the 'cs_tb_' prefix.",
    fieldsMapping: 'Fields mapping',
    messageField: 'Message Field',
    tableColumn: 'Table column',
    sourcePropertyPlaceholder: 'Enter source property',
    targetPropertyPlaceholder: 'Enter target property',
    addMapping: 'Add mapping',
    fieldsMappingNotEmpty: 'Fields mapping cannot have empty values!',
    inputValue: 'Input value',
    inputValueRequired: 'Input value is required!',
    outputValue: 'Output value',
    outputValueRequired: 'Output value is required!',
    decimalPlaces: 'Digits after the decimal point',
    tellFailureIfDeltaIsNegative: 'Failure if delta is negative',
    tellFailureIfDeltaIsNegativeHelp:
      'If the delta value is negative, the rule node forces a message processing failure.',
    useCache: 'Use cache',
    useCacheHelp:
      "The rule node will cache the 'pulseCounter' value from the incoming message to improve performance. Note that the cache will not be updated if you modify the 'pulseCounter' value elsewhere",
    addPeriodBetweenMsgs: "Add the time difference between 'pulseCounter' readings",
    addPeriodBetweenMsgsHelp: "If enabled, the rule node will add 'periodInMs' to the output message.",
    attributeMapping: 'Attribute mapping',
    telemetryMapping: 'Telemetry mapping',
    sourceAttribute: 'Source attribute',
    targetAttribute: 'Target attribute',
    sourceAttributePlaceholder: 'Enter source attribute',
    targetAttributePlaceholder: 'Enter target attribute',
    templatingHelp:
      'All input fields support templating. Use $[messageKey] to extract value from message, and ${metadataKey} to extract value from metadata.',
    addMappedAttributesTo: 'Add mapped attributes to',
    mappingRequired: 'Mapping is required!',
    selectDetails: 'Select details',
    selectDetailsRequired: 'Please select details!',
    addSelectedAttributesTo: 'Add selected attributes to',
    id: 'Id',
    title: 'Title',
    additionalInfo: 'Additional Info',
    country: 'Country',
    state: 'State',
    city: 'City',
    zip: 'Zip',
    address: 'Address',
    address2: 'Address2',
    phone: 'Phone',
    email: 'Email',
    fetchCredentialsTo: 'Fetch credentials to',
    originatorAttributes: 'Originator attributes',
    clientAttributes: 'Client attributes',
    sharedAttributes: 'Shared attributes',
    serverAttributes: 'Server attributes',
    latestTelemetry: 'Latest telemetry',
    getLatestValueWithTs: 'Get latest value with timestamp',
    addOriginatorAttributesTo: 'Add originator attributes to',
    tellFailureIfAbsent: 'Tell failure if any of the selected keys are not present in Message',
    tellFailureIfAbsentHelp:
      "The outgoing message will report 'Failure' if at least one of the selected keys is not present.",
    originatorAttributesRequired: 'At least one of the originator attributes must be filled in!',
    originatorFieldsMapping: 'Originator fields mapping',
    sourceField: 'Source field',
    targetField: 'Target field',
    targetFieldPlaceholder: 'Enter target field',
    targetFieldTemplatingHelp:
      'Target key fields support templating. Use $[messageKey] to extract value from message, and ${metadataKey} to extract value from metadata.',
    addOriginatorFieldsTo: 'Add originator fields to',
    skipNullFields: 'Skip null fields',
    createdTime: 'Created Time',
    name: 'Name',
    firstName: 'First Name',
    lastName: 'Last Name',
    label: 'Label',
    originatorFieldsMappingRequired: 'Originator fields mapping is required!',
    originatorFieldsMappingNotEmpty: 'Originator fields mapping cannot have empty values!',
    telemetryKeys: 'Telemetry keys',
    telemetryKeysRequired: 'Please select telemetry keys!',
    fetchInterval: 'Fetch interval',
    useDynamicInterval: 'Use dynamic interval',
    startInterval: 'Start interval',
    startIntervalRequired: 'Start interval is required!',
    timeUnit: 'Time unit',
    endInterval: 'End interval',
    endIntervalRequired: 'End interval is required!',
    fetchIntervalHelp:
      'Fetches time-series data from {startInterval} {startIntervalTimeUnit} ago to {endInterval} {endIntervalTimeUnit} ago.',
    dynamicIntervalHelp:
      'The start and end interval input fields support templating. Note that the substituted template value should be set in milliseconds. Use $[messageKey] to extract value from message, and ${metadataKey} to extract value from metadata.',
    fetchStrategy: 'Fetch strategy',
    fetchStrategyFirstHelp:
      "If you select the 'First' fetch mode, the rule node will retrieve the telemetry that is closest to the beginning of the fetch interval.",
    fetchStrategyLastHelp:
      "If you select the 'Last' fetch mode, the rule node will retrieve the telemetry that is closest to the end of the fetch interval.",
    fetchStrategyAllHelp:
      "If you select the 'All' fetch mode, the rule node will retrieve telemetry from the fetch interval using configurable query parameters.",
    dataAggregation: 'Data aggregation',
    timestampOrdering: 'Timestamp ordering',
    limit: 'Limit',
    limitRequired: 'Limit is required!',
    limitHelp:
      "The minimum limit value is 2, and the maximum is 1000. If you want to fetch a single entry, select the 'First' or 'Last' fetch mode.",
    gcpProjectId: 'GCP project ID',
    gcpProjectIdRequired: 'Please enter Project ID!',
    topicName: 'Topic name',
    topicNameRequired: 'Please enter Topic name!',
    gcpServiceAccountKeyFile: 'GCP service account key file',
    uploadFileHint: 'Drag and drop or click to select a file',
    messageAttribute: 'Message attribute',
    messageAttributeHelp:
      'In the name/value fields, use ${metadataKey} for values from metadata, and $[messageKey] for values from the message body',
    keyPlaceholder: 'Enter Key',
    valuePlaceholder: 'Enter Value',
    addAttribute: 'Add',
    messageAttributeNotEmpty: 'Message Attribute cannot have empty values!',
    uploadServiceAccountKeyFileRequired: 'Please upload the service account key file!',
    topicPattern: 'Topic Pattern',
    topicPatternRequired: 'Please enter Topic pattern!',
    topicPatternHelp:
      'Use ${metadataKey} for values from metadata, and $[messageKey] for values from the message body.',
    keyPattern: 'Key Pattern',
    keyPatternHelp:
      'Optional. If a valid partition number is specified, it will be used when sending the record. If no partition is specified, the key will be used. If neither is specified, a partition will be assigned in a round-robin fashion.',
    bootstrapServers: 'Bootstrap servers',
    bootstrapServersRequired: 'Please enter Bootstrap servers!',
    retries: 'Automatically retry times if fails',
    batchSize: 'Produces batch size in bytes',
    linger: 'Time to buffer locally',
    unitMillisecond: 'ms',
    bufferMemory: 'Client buffer max size in bytes',
    acks: 'Number of acknowledgements',
    acksRequired: 'Please select the number of acknowledgements',
    keySerializer: 'key serializer',
    keySerializerRequired: 'Please enter key serializer',
    valueSerializer: 'value serializer',
    valueSerializerRequired: 'Please enter value serializer',
    otherProperties: 'Other Properties',
    otherPropertiesNotEmpty: 'Other Property cannot have empty values!',
    addMetadataToKafkaHeaders: 'Add message metadata key-value pairs to Kafka record headers',
    addMetadataToKafkaHeadersHelp:
      'If checked, key-value pairs from the message metadata will be added to the outgoing record headers as byte arrays with a predefined charset encoding.',
    charsetEncoding: 'charset encoding',
    addProperty: 'Add Property',
    host: 'Host',
    hostRequired: 'Please enter host!',
    port: 'Port',
    portRequired: 'Please enter port!',
    connectTimeout: 'Connection timeout',
    connectTimeoutRequired: 'Please enter timeout!',
    clientId: 'Client ID',
    clientIdRequired: 'Please enter Client ID!',
    clientIdHelp:
      "Optional, leave empty for auto-generated client ID. Be careful when specifying the client ID. Most MQTT brokers do not allow multiple connections with the same client ID. To connect to such a broker, your MQTT client ID must be unique. When the platform is running in a microservices mode, a copy of the rule node is launched in each microservice. This will automatically result in multiple mqtt clients having the same ID and may cause the rule node to fail. To avoid such failures, enable the 'Add service ID as a suffix to the client ID' option below.",
    appendClientIdSuffix: 'Add Server ID as a suffix to the Client ID',
    appendClientIdSuffixHelp:
      "Optional, applies when 'Client ID' is explicitly specified. If checked, the Server ID will be added as a suffix to the Client ID. Helps to avoid failures when the platform is running in microservices mode.",
    cleanSession: 'Clean Session',
    retained: 'Retained',
    enableSSL: 'Enable SSL',
    credentials: 'Credentials',
    credentialsType: 'Credentials type',
    credentialsTypeRequired: 'Credentials type is required!',
    anonymous: 'Anonymous',
    basic: 'BASIC',
    username: 'Username',
    password: 'Password',
    exchangeNamePattern: 'Exchange name pattern',
    routingKeyPattern: 'Routing key pattern',
    messageProperties: 'Message properties',
    virtualHost: 'Virtual host',
    automaticRecovery: 'Automatic recovery',
    handshakeTimeout: 'Handshake timeout',
    clientProperties: 'Client Properties',
    clientPropertiesNotEmpty: 'Client Property cannot have empty values!',
    endpointUrlPattern: 'Endpoint URL pattern',
    endpointUrlPatternRequired: 'Endpoint URL is required!',
    requestMethod: 'Request method',
    requestMethodRequired: 'Request method is required!',
    enableProxy: 'Enable proxy',
    useSimpleClientHttpFactory: 'Use SimpleClientHttpFactory',
    parseToPlainText: 'Parse to plain text',
    parseToPlainTextHelp:
      'If checked, the request body message payload will be converted from a JSON string to a plain text string, e.g. msg=\"Hello,\\t\\t\"world\\\"\" will be parsed to Hello, \"world\"',
    ignoreRequestBody: 'Ignore Request Body',
    maxParallelRequestsCount: 'Max parallel requests count',
    useSystemProxyProperties: 'Use system proxy properties',
    proxyScheme: 'Proxy scheme',
    proxyHost: 'Proxy host',
    proxyPort: 'Proxy port',
    proxyUser: 'Proxy user',
    proxyPassword: 'Proxy password',
    httpHeaders: 'Http request headers',
    httpHeadersHelp:
      'Use ${metadataKey} for values from metadata, and $[messageKey] for values from the message body in the header/value fields',
    header: 'Header',
    headerPlaceholder: 'Enter Header',
    addHeader: 'Add',
    useRedisQueue: 'Use redis queue for message persistence',
    headerRequired: 'Header is required!',
    headerNotEmpty: 'Header cannot have empty values!',
    useSystemSmtpSettings: 'Use system SMTP settings',
    protocol: 'Protocol',
    smtpHost: 'SMTP Host',
    smtpHostRequired: 'SMTP Host is required!',
    smtpPort: 'SMTP Port',
    smtpPortRequired: 'SMTP Port is required!',
    enableTls: 'Enable TLS',
    tlsVersion: 'TLS version',
    proxyHostRequired: 'Proxy host is required!',
    proxyPortRequired: 'Proxy port is required!',
    template: 'Template',
    templateRequired: 'Please select a template!',
    templatePlaceholder: 'Please select a notification template',
    recipients: 'Recipients',
    recipientsRequired: 'Please select recipients!',
    recipientsPlaceholder: 'Please select recipients',
    phoneNumberTemplate: 'Phone number template',
    phoneNumberTemplateRequired: 'Please enter phone number template!',
    phoneNumberTemplateHelp:
      'Comma-separated list of phone numbers. Use ${metadataKey} for values from metadata, and $[messageKey] for values from the message body',
    smsMessageTemplate: 'SMS message template',
    smsMessageTemplateRequired: 'Please enter SMS message template!',
    smsMessageTemplateHelp:
      'Use ${metadataKey} for values from metadata, and $[messageKey] for values from the message body.',
    useSystemSmsProvider: 'Use system SMS provider settings',
    smsProvider: 'SMS Provider',
    aliyunSms: 'Alibaba Cloud SMS',
    awsSns: 'Amazon SNS',
    twilio: 'Twilio',
    smpp: 'SMPP',
    aliyunAccessKeyId: 'Alibaba Cloud Access Key ID',
    aliyunAccessKeySecret: 'Alibaba Cloud Access Key Secret',
    smsSignature: 'SMS Signature',
    smsTemplateCode: 'SMS Template Code',
    alarmStatus: 'Alarm status',
    alarmStatusRequired: 'Please select alarm status!',
    checkFields: 'Check fields',
    messageFields: 'Message fields',
    metadataFields: 'Metadata fields',
    checkPresenceOfAllFields: 'Check presence of all specified fields',
    checkFieldsRequired: 'Check fields are required!',
    relationSearchParameters: 'Relation search parameters',
    fromOriginator: 'From Originator',
    toOriginator: 'To Originator',
    enterRelationType: 'Please enter relation type',
    addRelationType: 'Add relation type',
    checkRelationToSpecificEntity: 'Check relation to a specific entity',
    coordinateFields: 'Coordinate fields',
    latitudeField: 'Latitude field',
    longitudeField: 'Longitude field',
    coordinateFieldsHelp:
      'The rule node tries to retrieve the specified fields from the message. If they are not present, it will look for them in the metadata.',
    geofencing: 'Geofencing',
    perimeterInfoField: 'Perimeter info field',
    perimeterInfoFieldRequired: 'Perimeter info field is required!',
    perimeterInfoFieldHelp: 'The name of the message metadata field that contains perimeter information.',
    messageType: 'Message type',
    messageTypeRequired: 'Please select message type!',
    postAttributes: 'Post Attributes',
    postTelemetry: 'Post Telemetry',
    rpcRequestToDevice: 'PRC Request to Device',
    rpcRequestFromDevice: 'PRC Request from Device',
    rpcQueued: 'RPC Queued',
    rpcSent: 'RPC Sent',
    rpcDelivered: 'RPC Delivered',
    rpcSuccessful: 'RPC Successful',
    rpcTimeout: 'RPC Timeout',
    rpcExpired: 'RPC Expired',
    rpcFailed: 'RPC Failed',
    rpcDeleted: 'RPC Deleted',
    activityEvent: 'Activity Event',
    inactivityEvent: 'InActivity Event',
    connectEvent: 'Connect Event',
    disconnectEvent: 'Disconnect Event',
    entityCreated: 'Entity Created',
    entityUpdated: 'Entity Updated',
    entityDeleted: 'Entity Deleted',
    entityAssigned: 'Entity Assigned',
    entityUnassigned: 'Entity UnAssigned',
    attributesUpdated: 'Attributes Updated',
    attributesDeleted: 'Attributes Deleted',
    alarmAcknowledged: 'Alarm Acknowledged',
    alarmCleared: 'Alarm Cleared',
    alarmAssigned: 'Alarm Assigned',
    alarmUnassigned: 'Alarm UnAssigned',
    commentCreated: 'Comment Created',
    commentUpdated: 'Comment Updated',
    entityAssignedFromTenant: 'Entity assigned from Tenant',
    entityAssignedToTenant: 'Entity Assigned to Tenant',
    timeseriesUpdated: 'Timeseries Updated',
    timeseriesDeleted: 'Timeseries Deleted',
    originatorSource: 'Originator source',
    originatorSourceRequired: 'Originator source is required!',
    customer: 'Customer',
    tenant: 'Tenant',
    related: 'Related',
    alarmOriginator: 'Alarm Originator',
    entityNameMatching: 'Entity name matching',
    relationQuery: 'Relation query',
    level: 'Level',
    relationFilters: 'Relation filters',
    anyType: 'Any type',
    addFilter: 'Add filter',
    entityNameMatchingPattern: 'Entity name matching pattern',
    namePatternHelp:
      'The name pattern field supports templating. Use $[messageKey] to extract value from message; use ${metadataKey} to extract value from metadata.',
    copyKeys: 'Copy keys',
    fromMessageToMetadata: 'From Message to Metadata',
    fromMetadataToMessage: 'From Metadata to Message',
    keysRequiredValidator: 'Keys cannot be empty!',
    keysRequiredOne: 'At least one key is required!',
    storage: 'Storage',
    first: 'First',
    last: 'Last',
    all: 'All',
    firstStrategyHelp: 'Returns the first message that arrived during the deduplication period.',
    lastStrategyHelp: 'Returns the last message that arrived during the deduplication period.',
    allStrategyHelp:
      'Returns all messages that arrived during the deduplication period as a single JSON array message; where each element represents an object with msg and metadata internal properties.',
    outputMessageType: 'Output message type',
    custom: 'Custom',
    outputMessageTypeValue: 'Output message type value',
    outputMessageTypeRequired: 'Please select output message type!',
    queueRequired: 'Please select a queue!',
    queuePlaceholder: 'Please select a queue',
    advancedSettings: 'Advanced settings',
    maxRetries: 'Maximum retries',
    valueRequired: 'Value cannot be empty!',
    intervalRequired: 'Interval cannot be empty!',
    deleteKeys: 'Delete keys',
    message: 'Message',
    metadata: 'Metadata',
    jsonPathExpression: 'JsonPath expression',
    jsonPathValueRequired: 'JsonPath value is required!',
    jsonPathRequired: 'JsonPath is required!',
    currentKey: 'Current key',
    renameKey: 'Rename key',
    keyMappingRequired: 'Key mapping is required!',
    keyMappingNotEmpty: 'Key mapping cannot have empty values!',
    testConversionFunction: 'Test conversion function',
    outputNodeHelp:
      'The rule node name corresponds to the relation type of the output message, which is used to forward messages to other rule nodes in the calling rule chain.',
    ruleChain: 'Rule chain',
    ruleChainRequired: 'Please select a rule chain!',
    ruleChainPlaceholder: 'Please select a rule chain',
    fetchLastLevelOnly: 'Fetch last level only',
    dataToFetch: 'Data to fetch',
    relationFiltersNotEmpty: 'Relation filters cannot have empty values!',
    attributes: 'Attributes',
    originatorFields: 'Fields',
    directionRequired: 'Please select a direction!',
    deviceRelationsQuery: 'Device relations query',
    deviceProfile: 'Device profile',
    deviceProfileRequired: 'Device profile is required!',
    relatedDeviceAttributes: 'Related device attributes',
    telemetry: 'Telemetry',
    emailSender: 'Email Sender',
    from: 'From',
    fromRequired: "Please enter the sender's email",
    recipientsHelp:
      'Comma-separated list of addresses. All input fields support templating. Use $[messageKey] to extract value from message, and ${metadataKey} to extract value from metadata.',
    to: 'To',
    toRequired: "Please enter recipient's email",
    cc: 'CC',
    bcc: 'BCC',
    subjectBody: 'Subject / Body',
    subject: 'Subject',
    subjectRequired: 'Please enter subject',
    mailBodyType: 'Mail Body Type',
    plainText: 'Plain Text',
    plainTextHelp: 'Simple, unformatted text without any special styling or formatting.',
    html: 'HTML',
    htmlHelp: 'Allows you to use HTML tags for formatting, links, and images in your mail body.',
    useBodyTypeTemplate: 'Use body type template',
    useBodyTypeTemplateHelp: 'Allows dynamic use of plain text or HTML body type based on templating functionality.',
    bodyTemplate: 'Body template',
    body: 'Body',
    bodyRequired: 'Please enter body',
  },
  debugSetting: {
    title: 'Debug Settings',
    rateLimitTip: 'Debug messages of all rule nodes are rate limited. Up to 50,000 messages per hour are allowed.',
    onlyFailures: 'Failures only ({duration})',
    onlyFailuresTip: 'Store all failed debug events with no time limit.',
    allMessages: 'All messages ({minutes} min)',
    allMessagesTip: 'Store all debug events within the event limit.',
    apply: 'Apply',
    cancel: 'Cancel',
    remaining: 'Remaining {time}',
    failures: 'Failures',
    disabled: 'Disabled',
    minutes: '{count} min',
    seconds: '{count} s',
  },
};
